# Algortihm 알고리즘

## [ 정렬 ]

### 버블 정렬
버블 정렬은 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘이다. 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬한다.  <br>
시간복잡도 : 𝑂(𝑛2)  <br>

### 힙 정렬
힙 정렬은 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘이다.
가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우이다. <br>
시간복잡도 : 𝑂(𝑛𝑙𝑜𝑔2𝑛)  <br>

### 합병 정렬 
주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘이다. <br>
시간복잡도 : 𝑂(𝑛𝑙𝑜𝑔2𝑛) <br>

### 퀵 정렬
매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할하는 정렬이다. 피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬한다. <br>
시간복잡도 : 𝑂(𝑛𝑙𝑜𝑔2𝑛) 
**리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도가 𝑂(𝑛2) 까지 나빠질 수 있다.** <br>

### 삽입 정렬
두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘이다. <br>
평균 시간복잡도 : 𝑂(𝑛2) 
**가장 빠른 경우 𝑂(𝑛) 까지 높아질 수 있다.** <br>

### 정렬 알고리즘 시간 복잡도 비교



## Dynamic Programming (DP, 동적 계획법, 동적 프로그래밍)

큰 문제를 작은 문제로 나누어 푸는 문제를 말한다. 즉, 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식이다. <br>

어떤 부분 문제가 다른 문제들을 해결하는 데 사용될 수 있어, 답을 여러 번 계산하는 대신 한번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상시킬 수 있다.


### Dynamic Programming의 두 가지 조건

Dynamic Programming으로 문제를 해결하기 위해서는 주어진 문제가 다음의 조건을 만족해야 한다.

- Overlapping Subproblem(중복되는 부분문제) <br>
주어진 문제에 같은 부분 문제가 여러번 재사용된다. <br>
즉, 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다. <br>

- Optimal Substructure(최적 부분구조) <br>
어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로 부터 설계될 수 있는 경우를 말한다. 즉, 최적 부분구조 일때 문제의 정답을 작은 문제의 정답에서 부터 구할 수 있다. <br>

### Dynamic Programming 사용하기

동적 계획법은 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이므로 다양한 문제해결에 쓰일 수 있다. <br>
>
일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다. <br>

1) DP로 풀 수 있는 문제인지 확인한다.
2) 문제의 변수 파악
3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)
5) 기저 상태 파악하기
6) 구현하기

<br>

## 재귀 알고리즘

함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘이다. 재귀 알고리즘은 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요하다. <br>

<br>

## 허프만 코딩

허프만 부호화 또는 허프만 코딩(Huffman coding)은 입력 파일의 문자 빈도 수를 가지고 최소힙을 이용하여 파일을 압축하는 과정이다.

<br>
